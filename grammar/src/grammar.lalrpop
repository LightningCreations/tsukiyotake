use crate::lex::Token;
use crate::ast;

use alloc::boxed::Box;
use alloc::vec::Vec;
use alloc::vec;
use core::str::FromStr;

use lalrpop_util::ParseError;

grammar<'src>(input: &'src str);

extern {
    type Location = usize;

    enum Token<'src> {
        "and" => Token::And, 
        "break" => Token::Break, 
        "do" => Token::Do, 
        "else" => Token::Else, 
        "elseif" => Token::ElseIf, 
        "end" => Token::End, 
        "false" => Token::False, 
        "for" => Token::For, 
        "function" => Token::Function, 
        "goto" => Token::Goto, 
        "if" => Token::If, 
        "in" => Token::In, 
        "local" => Token::Local, 
        "nil" => Token::Nil, 
        "not" => Token::Not, 
        "or" => Token::Or, 
        "repeat" => Token::Repeat, 
        "return" => Token::Return, 
        "then" => Token::Then, 
        "true" => Token::True, 
        "until" => Token::Until, 
        "while" => Token::While, 

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Modulo,
        "^" => Token::Hat,
        "#" => Token::Count,
        "&" => Token::BitAnd,
        "~" => Token::BitNot,
        "|" => Token::BitOr,
        "<<" => Token::LeftShift,
        ">>" => Token::RightShift,
        "//" => Token::IntDiv,
        "==" => Token::Equals,
        "~=" => Token::NotEquals,
        "<=" => Token::LessEquals,
        ">=" => Token::GreaterEquals,
        "<" => Token::LeftAngle,
        ">" => Token::RightAngle,
        "=" => Token::Assign,
        "(" => Token::OParen,
        ")" => Token::CParen,
        "{" => Token::OBrace,
        "}" => Token::CBrace,
        "[" => Token::OSquare,
        "]" => Token::CSquare,
        "::" => Token::ColonColon,
        ";" => Token::Semi,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        ".." => Token::DotDot,
        "..." => Token::DotDotDot,

        "ident" => Token::Ident(<&'src str>),
        "number" => Token::Number(<&'src str>),
        "string-literal" => Token::StringLiteral(<&'src str>),
        "raw-string" => Token::RawString(<&'src str>),
    }
}

Box<T>: Box<T> = <t: T> => Box::new(t);
Spanned<T>: ast::Spanned<T> = <l: @L> <t: T> <r: @R> => ast::Spanned(t, l..r);
List<T>: ast::List<T> = <t: Spanned<UnspannedList<T>>> => t;
DotList<T>: ast::List<T> = <t: Spanned<UnspannedDotList<T>>> => t;
FieldList: ast::List<ast::Field<'src>> = <t: Spanned<UnspannedFieldList>> => t;

UnspannedList<T>: Vec<ast::Spanned<T>> = {
    <t:Spanned<T>> => vec![t],
    <mut l:UnspannedList<T>> "," <t:Spanned<T>> => {
        l.push(t);
        l
    },
};

UnspannedDotList<T>: Vec<ast::Spanned<T>> = {
    <t:Spanned<T>> => vec![t],
    <mut l:UnspannedDotList<T>> "." <t:Spanned<T>> => {
        l.push(t);
        l
    },
};

UnspannedFieldList: Vec<ast::Spanned<ast::Field<'src>>> = {
    <mut v:(<Spanned<Field>> ",")*> <e:Spanned<Field>?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

String: Box<[u8]> = {
    <x:"string-literal"> => ast::parse_string(&x),
}

pub Block: ast::Block<'src> = {
    <stats:Spanned<Stat>*> <retstat:("return" <List<Exp>> ";"?)?> => ast::Block { stats, retstat },
}

pub Stat: ast::Stat<'src> = {
    ";" => ast::Stat::Empty,
    <vars:List<Var>> "=" <exps:List<Exp>> => ast::Stat::Assign { vars, exps },
    <Spanned<FunctionCall>> => ast::Stat::FunctionCall(<>),
    "::" <Spanned<"ident">> "::" => ast::Stat::Label(<>),
    "break" => ast::Stat::Break,
    "goto" <Spanned<"ident">> => ast::Stat::Goto(<>),
    "do" <Box<Spanned<Block>>> "end" => ast::Stat::DoBlock(<>),
    "while" <cond:Spanned<Exp>> "do" <block:Box<Spanned<Block>>> "end" => ast::Stat::While { cond, block },
    "repeat" <block:Box<Spanned<Block>>> "until" <cond:Spanned<Exp>> "end" => ast::Stat::RepeatUntil { block, cond },
    "if" <main:CondThenBlock> <elseifs:("elseif" <CondThenBlock>)*> <else_block:("else" <Box<Spanned<Block>>>)?> "end" => {
        ast::Stat::If {
            main,
            elseifs,
            else_block,
        }
    },
    "for" <var:Spanned<"ident">> "=" <initial:Spanned<Exp>> "," <limit:Spanned<Exp>> <step:("," <Spanned<Exp>>)?> "do" <block:Box<Spanned<Block>>> "end" => {
        ast::Stat::ForNumerical {
            var,
            initial,
            limit,
            step,
            block,
        }
    },
    "for" <names:List<"ident">> "in" <exps:List<Exp>> "do" <block:Box<Spanned<Block>>> "end" => {
        ast::Stat::ForGeneric {
            names,
            exps,
            block,
        }
    },
    "function" <name:Spanned<FuncName>> <body:Spanned<FuncBody>> => {
        ast::Stat::Function {
            name,
            body,
        }
    },
    "local" "function" <name:Spanned<"ident">> <body:Spanned<FuncBody>> => {
        ast::Stat::LocalFunction {
            name,
            body,
        }
    },
    "local" <names:List<AttName>> <exps:("=" <List<Exp>>)?> => {
        ast::Stat::Local {
            names,
            exps,
        }
    },
}

AttName: ast::AttName<'src> = {
    <name:Spanned<"ident">> <attrib:("<" <Spanned<"ident">> ">")?> => ast::AttName { name, attrib },
}

CondThenBlock: (ast::Spanned<ast::Exp<'src>>, Box<ast::Spanned<ast::Block<'src>>>) = {
    <Spanned<Exp>> "then" <Box<Spanned<Block>>> => (<>),
}

pub FuncName: ast::FuncName<'src> = {
    <path:DotList<"ident">> <method:(":" <Spanned<"ident">>)?> => ast::FuncName { path, method },
}

pub Var: ast::Var<'src> = {
    <name:Spanned<"ident">> => ast::Var::Name(name),
    <lhs:Box<Spanned<PrefixExp>>> "[" <idx:Box<Spanned<Exp>>> "]" => {
        ast::Var::Index {
            lhs,
            idx,
        }
    },
    <lhs:Box<Spanned<PrefixExp>>> "." <member:Spanned<"ident">> => {
        ast::Var::Path {
            lhs,
            member,
        }
    },
}

pub Exp: ast::Exp<'src> = {
    #[precedence(level="0")]
    "nil" => ast::Exp::Nil,
    "false" => ast::Exp::False,
    "true" => ast::Exp::True,
    <Spanned<"number">> =>? {
        if let Ok(x) = i64::from_str(*<>) {
            Ok(ast::Exp::NumeralInt(ast::Spanned(x, <>.1)))
        } else if let Ok(x) = f64::from_str(*<>) {
            Ok(ast::Exp::NumeralFloat(ast::Spanned(x, <>.1))) // TODO: Proper float parsing
        } else {
            Err(ParseError::User {
                error: "number is too big"
            })
        }
    },
    <Spanned<String>> => ast::Exp::LiteralString(<>),
    "..." => ast::Exp::VarArg,
    "function" <Spanned<FuncBody>> => ast::Exp::FunctionDef(<>),
    <Spanned<PrefixExp>> => ast::Exp::PrefixExp(<>),
    "{" <FieldList> "}" => ast::Exp::TableConstructor(<>),

    #[precedence(level="1")] #[assoc(side="right")]
    <lhs:Box<Spanned<Exp>>> "^" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Pow,
        rhs,
    },

    #[precedence(level="2")]
    "not" <rhs:Box<Spanned<Exp>>> => ast::Exp::UnExp {
        op: ast::UnOp::Not,
        rhs,
    },
    "#" <rhs:Box<Spanned<Exp>>> => ast::Exp::UnExp {
        op: ast::UnOp::Len,
        rhs,
    },
    "-" <rhs:Box<Spanned<Exp>>> => ast::Exp::UnExp {
        op: ast::UnOp::Unm,
        rhs,
    },
    "~" <rhs:Box<Spanned<Exp>>> => ast::Exp::UnExp {
        op: ast::UnOp::Bnot,
        rhs,
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "*" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Mul,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> "/" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Div,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> "//" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Idiv,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> "%" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Mod,
        rhs,
    },

    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "+" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Add,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> "-" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Sub,
        rhs,
    },

    #[precedence(level="5")] #[assoc(side="right")]
    <lhs:Box<Spanned<Exp>>> ".." <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Concat,
        rhs,
    },

    #[precedence(level="6")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "<<" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Shl,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> ">>" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Shr,
        rhs,
    },

    #[precedence(level="7")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "&" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Band,
        rhs,
    },

    #[precedence(level="8")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "~" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Bxor,
        rhs,
    },

    #[precedence(level="9")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "|" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Bor,
        rhs,
    },

    #[precedence(level="10")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "<" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Lt,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> ">" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Gt,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> "<=" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Le,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> ">=" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Ge,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> "~=" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Neq,
        rhs,
    },
    <lhs:Box<Spanned<Exp>>> "==" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Eq,
        rhs,
    },

    #[precedence(level="11")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "and" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::And,
        rhs,
    },

    #[precedence(level="12")] #[assoc(side="left")]
    <lhs:Box<Spanned<Exp>>> "or" <rhs:Box<Spanned<Exp>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Or,
        rhs,
    },
}

pub PrefixExp: ast::PrefixExp<'src> = {
    <Spanned<Var>> => ast::PrefixExp::Var(<>),
    <Spanned<FunctionCall>> => ast::PrefixExp::FunctionCall(<>),
}

pub FunctionCall: ast::FunctionCall<'src> = {
    <lhs:Box<Spanned<PrefixExp>>> <method:(":" <Spanned<"ident">>)?> <args:Spanned<Args>> => {
        ast::FunctionCall {
            lhs,
            method,
            args
        }
    },
}

pub Args: ast::Args<'src> = {
    "(" <x:List<Exp>> ")" => ast::Args::List(x),
}

ParamList: (Vec<ast::Spanned<&'src str>>, Option<ast::Spanned<()>>) = {
    <Spanned<"...">> => (vec![], Some(<>.map(|_| ()))),
    <first:Spanned<"ident">> <mut list:("," <Spanned<"ident">>)*> => {
        list.insert(0, first);
        (list, None)
    },
    <first:Spanned<"ident">> <mut list:("," <Spanned<"ident">>)*> "," <varargs:Spanned<"...">> => {
        list.insert(0, first);
        (list, Some(varargs.map(|_| ())))
    }
}

pub FuncBody: ast::FuncBody<'src> = {
    "(" <params:Spanned<ParamList?>> ")" <block:Spanned<Block>> "end" => {
        ast::FuncBody {
            params: params.clone().map(|x| if let Some(x) = x { x.0 } else { vec![] }),
            varargs: params.0.and_then(|x| x.1),
            block,
        }
    },
}

pub Field: ast::Field<'src> = {
    "[" <field:Box<Spanned<Exp>>> "]" "=" <val:Box<Spanned<Exp>>> => {
        ast::Field::Exp {
            field,
            val,
        }
    },
    <field:Spanned<"ident">> "=" <val:Box<Spanned<Exp>>> => {
        ast::Field::Named {
            field,
            val,
        }
    },
    <val:Box<Spanned<Exp>>> => {
        ast::Field::Unnamed {
            val,
        }
    },
}
