use crate::lex::Token;
use crate::ast;

use alloc::borrow::Cow;
use alloc::boxed::Box;
use alloc::vec::Vec;
use alloc::vec;
use core::str::FromStr;

use lalrpop_util::ParseError;

grammar<'src>(input: &'src str);

extern {
    type Location = usize;

    enum Token<'src> {
        "and" => Token::And, 
        "break" => Token::Break, 
        "do" => Token::Do, 
        "else" => Token::Else, 
        "elseif" => Token::ElseIf, 
        "end" => Token::End, 
        "false" => Token::False, 
        "for" => Token::For, 
        "function" => Token::Function, 
        "goto" => Token::Goto, 
        "if" => Token::If, 
        "in" => Token::In, 
        "local" => Token::Local, 
        "nil" => Token::Nil, 
        "not" => Token::Not, 
        "or" => Token::Or, 
        "repeat" => Token::Repeat, 
        "return" => Token::Return, 
        "then" => Token::Then, 
        "true" => Token::True, 
        "until" => Token::Until, 
        "while" => Token::While, 

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Modulo,
        "^" => Token::Hat,
        "#" => Token::Count,
        "&" => Token::BitAnd,
        "~" => Token::BitNot,
        "|" => Token::BitOr,
        "<<" => Token::LeftShift,
        ">>" => Token::RightShift,
        "//" => Token::IntDiv,
        "==" => Token::Equals,
        "~=" => Token::NotEquals,
        "<=" => Token::LessEquals,
        ">=" => Token::GreaterEquals,
        "<" => Token::LeftAngle,
        ">" => Token::RightAngle,
        "=" => Token::Assign,
        "(" => Token::OParen,
        ")" => Token::CParen,
        "{" => Token::OBrace,
        "}" => Token::CBrace,
        "[" => Token::OSquare,
        "]" => Token::CSquare,
        "::" => Token::ColonColon,
        ";" => Token::Semi,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        ".." => Token::DotDot,
        "..." => Token::DotDotDot,

        "ident" => Token::Ident(<&'src str>),
        "number" => Token::Number(<&'src str>),
        "string-literal" => Token::StringLiteral(<&'src str>),
        "raw-string" => Token::RawString(<&'src str>),
    }
}

Box<T>: Box<T> = <t: T> => Box::new(t);
Spanned<T>: ast::Spanned<T> = <l: @L> <t: T> <r: @R> => ast::Spanned(t, l..r);
List<T>: ast::List<T> = <t: Spanned<UnspannedList<T>>> => t;
ListForceTerminator<T, U>: ast::List<T> = <t: Spanned<UnspannedListForceTerminator<T, U>>> => t;
ListForceInitial<T, U>: ast::List<T> = <t: Spanned<UnspannedListForceInitial<T, U>>> => t;
DotList<T>: ast::List<T> = <t: Spanned<UnspannedDotList<T>>> => t;
FieldList: ast::List<ast::Field<'src>> = <t: Spanned<UnspannedFieldList>> => t;

UnspannedList<T>: Vec<ast::Spanned<T>> = {
    <t:Spanned<T>> => vec![t],
    <mut l:UnspannedList<T>> "," <t:Spanned<T>> => {
        l.push(t);
        l
    },
};

UnspannedListForceTerminator<T, U>: Vec<ast::Spanned<T>> = {
    <t:Spanned<U>> => vec![t],
    <mut l:UnspannedList<T>> "," <t:Spanned<U>> => {
        l.push(t);
        l
    },
};

UnspannedListForceInitial<T, U>: Vec<ast::Spanned<T>> = {
    <t:Spanned<U>> => vec![t],
    <mut l:UnspannedListForceInitial<T, U>> "," <t:Spanned<U>> => {
        l.push(t);
        l
    },
};

UnspannedDotList<T>: Vec<ast::Spanned<T>> = {
    <t:Spanned<T>> => vec![t],
    <mut l:UnspannedDotList<T>> "." <t:Spanned<T>> => {
        l.push(t);
        l
    },
};

UnspannedFieldList: Vec<ast::Spanned<ast::Field<'src>>> = {
    <mut v:(<Spanned<Field>> ",")*> <e:Spanned<Field>?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

String: Box<[u8]> = {
    <x:"string-literal"> => ast::parse_string(&x),
}

pub Block: ast::Block<'src> = {
    <stats:Statements> <retstat:("return" <ListForceTerminator<ExpAny, ExpAny>> ";"?)?> => ast::Block { stats, retstat },
}

FullStatements: Vec<ast::Stat<'src>> = {
    <Statements> => <>,
    <StatementsTrailingVar> => <>,
}

Statements: Vec<ast::Stat<'src>> = {
    /* empty */ => vec![],
    <mut list:Statements> <next:StatAnyStart<"no var">> => { list.push(next); list },
    <mut list:StatementsTrailingVar> <next:Stat<"no parens", "no var">> => { list.push(next); list },
}

StatementsTrailingVar: Vec<ast::Stat<'src>> = {
    <mut list:Statements> <next:StatAnyStart<"force var">> => { list.push(next); list },
    <mut list:StatementsTrailingVar> <next:Stat<"no parens", "force var">> => { list.push(next); list },
}

StatAnyStart<EndConstraints>: ast::Stat<'src> = {
    Stat<"force parens", EndConstraints>,
    Stat<"no parens", EndConstraints>,
}

Stat<StartConstraints, EndConstraints>: ast::Stat<'src> = {
    ";" if EndConstraints != "force var" => ast::Stat::Empty,
    <vars:ListForceInitial<Var<StartConstraints>, AnyVar>> "=" <exps:ListForceTerminator<ExpAny, ExpAnyStart<EndConstraints>>> => {
        ast::Stat::Assign { vars, exps }
    },
    <Spanned<FunctionCall<StartConstraints>>> if EndConstraints != "no var" => ast::Stat::FunctionCall(<>),
    "::" <Spanned<"ident">> "::" if EndConstraints != "force var" => ast::Stat::Label(<>.map(|x| x.into())),
    "break" if EndConstraints != "force var" => ast::Stat::Break,
    "goto" <Spanned<"ident">> if EndConstraints != "force var" => ast::Stat::Goto(<>.map(|x| x.into())),
    "do" <Box<Spanned<Block>>> "end" if EndConstraints != "force var" => ast::Stat::DoBlock(<>),
    "while" <cond:Spanned<ExpAny>> "do" <block:Box<Spanned<Block>>> "end"
        if EndConstraints != "force var" => {
        ast::Stat::While { cond, block }
    },
    "repeat" <block:Box<Spanned<Block>>> "until" <cond:Spanned<ExpAny>> "end"
        if EndConstraints != "force var" => {
        ast::Stat::RepeatUntil { block, cond }
    },
    "if" <main:CondThenBlock> <elseifs:("elseif" <CondThenBlock>)*> <else_block:("else" <Box<Spanned<Block>>>)?> "end"
        if EndConstraints != "force var" => {
        ast::Stat::If {
            main,
            elseifs,
            else_block,
        }
    },
    "for" <var:Spanned<"ident">> "=" <initial:Spanned<ExpAny>> "," <limit:Spanned<ExpAny>> <step:("," <Spanned<ExpAny>>)?> "do" <block:Box<Spanned<Block>>> "end"
        if EndConstraints != "force var" => {
        ast::Stat::ForNumerical {
            var: var.map(|x| x.into()),
            initial,
            limit,
            step,
            block,
        }
    },
    "for" <names:List<"ident">> "in" <exps:ListForceTerminator<ExpAny, ExpAny>> "do" <block:Box<Spanned<Block>>> "end"
        if EndConstraints != "force var" => {
        ast::Stat::ForGeneric {
            names: names.map(|x| x.into_iter().map(|x| x.map(|x| x.into())).collect()),
            exps,
            block,
        }
    },
    "function" <name:Spanned<FuncName>> <body:Spanned<FuncBody>>
        if EndConstraints != "force var" => {
        ast::Stat::Function {
            name,
            body,
        }
    },
    "local" "function" <name:Spanned<"ident">> <body:Spanned<FuncBody>>
        if EndConstraints != "force var" => {
        ast::Stat::LocalFunction {
            name: name.map(|x| x.into()),
            body,
        }
    },
    "local" <names:ListForceTerminator<AttNameAny, AttName<EndConstraints>>> => {
        ast::Stat::Local {
            names,
            exps: None,
        }
    },
    "local" <names:ListForceTerminator<AttNameAny, AttNameAny>> <exps:("=" <ListForceTerminator<ExpAny, ExpAnyStart<EndConstraints>>>)> => {
        ast::Stat::Local {
            names,
            exps: Some(exps),
        }
    },
}

AttName<EndConstraints>: ast::AttName<'src> = {
    <name:Spanned<"ident">>
    if EndConstraints != "no var" => {
        ast::AttName {
            name: name.map(|x| x.into()),
            attrib: None
        }
    },
    <name:Spanned<"ident">> <attrib:("<" <Spanned<"ident">> ">")>
    if EndConstraints != "force var" => {
        ast::AttName {
            name: name.map(|x| x.into()),
            attrib: Some(attrib.map(|x| x.into()))
        }
    },
}

AttNameAny: ast::AttName<'src> = {
    AttName<"force var">,
    AttName<"no var">,
}

CondThenBlock: (ast::Spanned<ast::Exp<'src>>, Box<ast::Spanned<ast::Block<'src>>>) = {
    <Spanned<ExpAny>> "then" <Box<Spanned<Block>>> => (<>),
}

pub FuncName: ast::FuncName<'src> = {
    <path:DotList<"ident">> <method:(":" <Spanned<"ident">>)?> => ast::FuncName { path: path.map(|x| x.into_iter().map(|x| x.map(|x| x.into())).collect()), method: method.map(|x| x.map(|x| x.into())) },
}

AnyVar: ast::Var<'src> = {
    Var<"no parens">,
    Var<"parens">,
}

// if the ending constraint requires a var or not a var, it should be handled *way* above this
Var<StartConstraints>: ast::Var<'src> = {
    <name:Spanned<"ident">> if StartConstraints != "force parens" => ast::Var::Name(name.map(|x| x.into())),
    <lhs:Box<Spanned<PrefixExp<StartConstraints>>>> "[" <idx:Box<Spanned<ExpAny>>> "]" => {
        ast::Var::Index {
            lhs,
            idx,
        }
    },
    <lhs:Box<Spanned<PrefixExp<StartConstraints>>>> "." <member:Spanned<"ident">> => {
        ast::Var::Path {
            lhs,
            member: member.map(|x| x.into()),
        }
    },
}

// The below is what we will have when lalrpop merges lalrpop#667. Currently, this kind of code completely explodes.
// As such, below this is a complete rewrite of this with bespoke precedence levels.
// ---
// Exp<StartConstraints, EndConstraints>: ast::Exp<'src> = {
//     #[precedence(level="0")]
//     "nil" if EndConstraints != "force var" => ast::Exp::Nil,
//     "false" if EndConstraints != "force var" => ast::Exp::False,
//     "true" if EndConstraints != "force var" => ast::Exp::True,
//     <Spanned<"number">> if EndConstraints != "force var" =>? {
//         if let Ok(x) = i64::from_str(*<>) {
//             Ok(ast::Exp::NumeralInt(ast::Spanned(x, <>.1)))
//         } else if let Ok(x) = f64::from_str(*<>) {
//             Ok(ast::Exp::NumeralFloat(ast::Spanned(x, <>.1))) // TODO: Proper float parsing
//         } else {
//             Err(ParseError::User {
//                 error: "number is too big"
//             })
//         }
//     },
//     <Spanned<String>> if EndConstraints != "force var" => ast::Exp::LiteralString(<>),
//     "..." if EndConstraints != "force var" => ast::Exp::VarArg,
//     "function" <Spanned<FuncBody>> if EndConstraints != "force var" => ast::Exp::FunctionDef(<>),
//     <Spanned<PrefixExp<StartConstraints>>> if EndConstraints != "no var" => ast::Exp::PrefixExp(<>),
//     "{" <FieldList> "}" if EndConstraints != "force var" => ast::Exp::TableConstructor(<>),
//
//     #[precedence(level="1")] #[assoc(side="right")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "^" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Pow,
//         rhs,
//     },
//
//     #[precedence(level="2")]
//     "not" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::UnExp {
//         op: ast::UnOp::Not,
//         rhs,
//     },
//     "#" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::UnExp {
//         op: ast::UnOp::Len,
//         rhs,
//     },
//     "-" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::UnExp {
//         op: ast::UnOp::Unm,
//         rhs,
//     },
//     "~" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::UnExp {
//         op: ast::UnOp::Bnot,
//         rhs,
//     },
//
//     #[precedence(level="3")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "*" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Mul,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "/" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Div,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "//" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Idiv,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "%" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Mod,
//         rhs,
//     },
//
//     #[precedence(level="4")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "+" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Add,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "-" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Sub,
//         rhs,
//     },
//
//     #[precedence(level="5")] #[assoc(side="right")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> ".." <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Concat,
//         rhs,
//     },
//
//     #[precedence(level="6")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "<<" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Shl,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> ">>" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Shr,
//         rhs,
//     },
//
//     #[precedence(level="7")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "&" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Band,
//         rhs,
//     },
//
//     #[precedence(level="8")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "~" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Bxor,
//         rhs,
//     },
//
//     #[precedence(level="9")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "|" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Bor,
//         rhs,
//     },
//
//     #[precedence(level="10")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "<" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Lt,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> ">" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Gt,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "<=" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Le,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> ">=" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Ge,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "~=" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Neq,
//         rhs,
//     },
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "==" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Eq,
//         rhs,
//     },
//
//     #[precedence(level="11")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "and" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::And,
//         rhs,
//     },
//
//     #[precedence(level="12")] #[assoc(side="left")]
//     <lhs:Box<Spanned<Exp<StartConstraints, "">>>> "or" <rhs:Box<Spanned<Exp<"", EndConstraints>>>> => ast::Exp::BinExp {
//         lhs,
//         op: ast::BinOp::Or,
//         rhs,
//     },
// }

Exp0Var<StartConstraints>: ast::Exp<'src> = {
    <Spanned<PrefixExp<StartConstraints>>> => ast::Exp::PrefixExp(<>),
}

Exp0NoVar<StartConstraints>: ast::Exp<'src> = {
    "nil" if StartConstraints != "force parens" => ast::Exp::Nil,
    "false" if StartConstraints != "force parens" => ast::Exp::False,
    "true" if StartConstraints != "force parens" => ast::Exp::True,
    <Spanned<"number">> if StartConstraints != "force parens" =>? {
        if let Ok(x) = i64::from_str(*<>) {
            Ok(ast::Exp::NumeralInt(ast::Spanned(x, <>.1)))
        } else if let Ok(x) = f64::from_str(*<>) {
            Ok(ast::Exp::NumeralFloat(ast::Spanned(x, <>.1))) // TODO: Proper float parsing
        } else {
            Err(ParseError::User {
                error: "number is too big"
            })
        }
    },
    <Spanned<String>> if StartConstraints != "force parens" => ast::Exp::LiteralString(<>),
    "..." if StartConstraints != "force parens" => ast::Exp::VarArg,
    "function" <Spanned<FuncBody>> if StartConstraints != "force parens" => ast::Exp::FunctionDef(<>),
    "{" <FieldList> "}" if StartConstraints != "force parens" => ast::Exp::TableConstructor(<>),
}

Exp0<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    Exp0Var<EndConstraints> if EndConstraints == "force var",
    Exp0NoVar<EndConstraints> if EndConstraints == "no var",
}

Exp0AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp0<StartConstraints, "force var">,
    Exp0<StartConstraints, "no var">,
}

Exp1<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    // not a typo; rather, right-associativity
    <lhs:Box<Spanned<Exp0AnyEnd<StartConstraints>>>> "^" <rhs:Box<Spanned<Exp1AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Pow,
        rhs,
    },
    Exp0<StartConstraints, EndConstraints>
}

Exp1AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp1<"force parens", EndConstraints>,
    Exp1<"no parens", EndConstraints>,
}

Exp2<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    "not" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> if StartConstraints != "force parens" => ast::Exp::UnExp {
        op: ast::UnOp::Not,
        rhs,
    },
    "#" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> if StartConstraints != "force parens" => ast::Exp::UnExp {
        op: ast::UnOp::Len,
        rhs,
    },
    "-" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> if StartConstraints != "force parens" => ast::Exp::UnExp {
        op: ast::UnOp::Unm,
        rhs,
    },
    "~" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> if StartConstraints != "force parens" => ast::Exp::UnExp {
        op: ast::UnOp::Bnot,
        rhs,
    },
    Exp1<StartConstraints, EndConstraints>
}

Exp2AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp2<"force parens", EndConstraints>,
    Exp2<"no parens", EndConstraints>,
}

Exp3<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp3AnyEnd<StartConstraints>>>> "*" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Mul,
        rhs,
    },
    <lhs:Box<Spanned<Exp3AnyEnd<StartConstraints>>>> "/" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Div,
        rhs,
    },
    <lhs:Box<Spanned<Exp3AnyEnd<StartConstraints>>>> "//" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Idiv,
        rhs,
    },
    <lhs:Box<Spanned<Exp3AnyEnd<StartConstraints>>>> "%" <rhs:Box<Spanned<Exp2AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Mod,
        rhs,
    },
    Exp2<StartConstraints, EndConstraints>
}

Exp3AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp3<"force parens", EndConstraints>,
    Exp3<"no parens", EndConstraints>,
}

Exp3AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp3<StartConstraints, "force var">,
    Exp3<StartConstraints, "no var">,
}

Exp4<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp4AnyEnd<StartConstraints>>>> "+" <rhs:Box<Spanned<Exp3AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Add,
        rhs,
    },
    <lhs:Box<Spanned<Exp4AnyEnd<StartConstraints>>>> "-" <rhs:Box<Spanned<Exp3AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Sub,
        rhs,
    },
    Exp3<StartConstraints, EndConstraints>
}

Exp4AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp4<StartConstraints, "force var">,
    Exp4<StartConstraints, "no var">,
}

Exp5<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    // not a typo; rather, right-associativity
    <lhs:Box<Spanned<Exp4AnyEnd<StartConstraints>>>> ".." <rhs:Box<Spanned<Exp5AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Concat,
        rhs,
    },
    Exp4<StartConstraints, EndConstraints>
}

Exp5AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp5<"force parens", EndConstraints>,
    Exp5<"no parens", EndConstraints>,
}

Exp6<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp6AnyEnd<StartConstraints>>>> "<<" <rhs:Box<Spanned<Exp5AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Shl,
        rhs,
    },
    <lhs:Box<Spanned<Exp6AnyEnd<StartConstraints>>>> ">>" <rhs:Box<Spanned<Exp5AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Shr,
        rhs,
    },
    Exp5<StartConstraints, EndConstraints>
}

Exp6AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp6<"force parens", EndConstraints>,
    Exp6<"no parens", EndConstraints>,
}

Exp6AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp6<StartConstraints, "force var">,
    Exp6<StartConstraints, "no var">,
}

Exp7<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp7AnyEnd<StartConstraints>>>> "&" <rhs:Box<Exp6AnyStart<EndConstraints>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Band,
        rhs,
    },
    Exp6<StartConstraints, EndConstraints>
}

Exp7AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp7<"force parens", EndConstraints>,
    Exp7<"no parens", EndConstraints>,
}

Exp7AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp7<StartConstraints, "force var">,
    Exp7<StartConstraints, "no var">,
}

Exp8<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp8AnyEnd<StartConstraints>>>> "~" <rhs:Box<Spanned<Exp7AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Bxor,
        rhs,
    },
    Exp7<StartConstraints, EndConstraints>
}

Exp8AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp8<"force parens", EndConstraints>,
    Exp8<"no parens", EndConstraints>,
}

Exp8AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp8<StartConstraints, "force var">,
    Exp8<StartConstraints, "no var">,
}

Exp9<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp9AnyEnd<StartConstraints>>>> "|" <rhs:Box<Spanned<Exp8AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Bor,
        rhs,
    },
    Exp8<StartConstraints, EndConstraints>
}

Exp9AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp9<"force parens", EndConstraints>,
    Exp9<"no parens", EndConstraints>,
}

Exp9AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp9<StartConstraints, "force var">,
    Exp9<StartConstraints, "no var">,
}

Exp10<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp10AnyEnd<StartConstraints>>>> "<" <rhs:Box<Spanned<Exp9AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Lt,
        rhs,
    },
    <lhs:Box<Spanned<Exp10AnyEnd<StartConstraints>>>> ">" <rhs:Box<Spanned<Exp9AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Gt,
        rhs,
    },
    <lhs:Box<Spanned<Exp10AnyEnd<StartConstraints>>>> "<=" <rhs:Box<Spanned<Exp9AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Le,
        rhs,
    },
    <lhs:Box<Spanned<Exp10AnyEnd<StartConstraints>>>> ">=" <rhs:Box<Spanned<Exp9AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Ge,
        rhs,
    },
    <lhs:Box<Spanned<Exp10AnyEnd<StartConstraints>>>> "~=" <rhs:Box<Spanned<Exp9AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Neq,
        rhs,
    },
    <lhs:Box<Spanned<Exp10AnyEnd<StartConstraints>>>> "==" <rhs:Box<Spanned<Exp9AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Eq,
        rhs,
    },
    Exp9<StartConstraints, EndConstraints>
}

Exp10AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp10<"force parens", EndConstraints>,
    Exp10<"no parens", EndConstraints>,
}

Exp10AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp10<StartConstraints, "force var">,
    Exp10<StartConstraints, "no var">,
}

Exp11<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<Exp11AnyEnd<StartConstraints>>>> "and" <rhs:Box<Spanned<Exp10AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::And,
        rhs,
    },
    Exp10<StartConstraints, EndConstraints>
}

Exp11AnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp11<"force parens", EndConstraints>,
    Exp11<"no parens", EndConstraints>,
}

Exp11AnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp11<StartConstraints, "force var">,
    Exp11<StartConstraints, "no var">,
}

Exp<StartConstraints, EndConstraints>: ast::Exp<'src> = {
    <lhs:Box<Spanned<ExpAnyEnd<StartConstraints>>>> "or" <rhs:Box<Spanned<Exp11AnyStart<EndConstraints>>>> => ast::Exp::BinExp {
        lhs,
        op: ast::BinOp::Or,
        rhs,
    },
    Exp11<StartConstraints, EndConstraints>
}

ExpAnyStart<EndConstraints>: ast::Exp<'src> = {
    Exp<"force parens", EndConstraints>,
    Exp<"no parens", EndConstraints>,
}

ExpAnyEnd<StartConstraints>: ast::Exp<'src> = {
    Exp<StartConstraints, "force var">,
    Exp<StartConstraints, "no var">,
}

ExpAny: ast::Exp<'src> = {
    Exp<"force parens", "force var">,
    Exp<"force parens", "no var">,
    Exp<"no parens", "force var">,
    Exp<"no parens", "no var">,
}

PrefixExp<StartConstraints>: ast::PrefixExp<'src> = {
    <Spanned<Var<StartConstraints>>> => ast::PrefixExp::Var(<>),
    <Spanned<FunctionCall<StartConstraints>>> => ast::PrefixExp::FunctionCall(<>),
    "(" <Spanned<ExpAny>> ")" if StartConstraints != "no parens" => ast::PrefixExp::Parens(<>),
}

FunctionCall<StartConstraints>: ast::FunctionCall<'src> = {
    <lhs:Box<Spanned<PrefixExp<StartConstraints>>>> <method:(":" <Spanned<"ident">>)?> <args:Spanned<Args>> => {
        ast::FunctionCall {
            lhs,
            method: method.map(|x| x.map(|x| x.into())),
            args,
        }
    },
}

pub Args: ast::Args<'src> = {
    "(" <x:ListForceTerminator<ExpAny, ExpAny>> ")" => ast::Args::List(x),
}

ParamList: (Vec<ast::Spanned<Cow<'src, str>>>, Option<ast::Spanned<()>>) = {
    <Spanned<"...">> => (vec![], Some(<>.map(|_| ()))),
    <first:Spanned<"ident">> <list:("," <Spanned<"ident">>)*> => {
        let list = core::iter::once(first).chain(list.into_iter()).map(|x| x.map(|x| x.into())).collect();
        (list, None)
    },
    <first:Spanned<"ident">> <list:("," <Spanned<"ident">>)*> "," <varargs:Spanned<"...">> => {
        let list = core::iter::once(first).chain(list.into_iter()).map(|x| x.map(|x| x.into())).collect();
        (list, Some(varargs.map(|_| ())))
    }
}

pub FuncBody: ast::FuncBody<'src> = {
    "(" <params:Spanned<ParamList?>> ")" <block:Spanned<Block>> "end" => {
        ast::FuncBody {
            params: params.clone().map(|x| if let Some(x) = x { x.0 } else { vec![] }),
            varargs: params.0.and_then(|x| x.1),
            block,
        }
    },
}

pub Field: ast::Field<'src> = {
    "[" <field:Box<Spanned<ExpAny>>> "]" "=" <val:Box<Spanned<ExpAny>>> => {
        ast::Field::Exp {
            field,
            val,
        }
    },
    <field:Spanned<"ident">> "=" <val:Box<Spanned<ExpAny>>> => {
        ast::Field::Named {
            field: field.map(|x| x.into()),
            val,
        }
    },
    <val:Box<Spanned<ExpAny>>> => {
        ast::Field::Unnamed {
            val,
        }
    },
}
